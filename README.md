# Web-applications-for-automating-the-search-for-commercial-product-names
Web-application React.js.  Web applications for automating the search for commercial product names

После – добавляется базовый код для всех компонентов React. Для начала осуществляем импорт библиотеки React и каскадной таблицы стилей. Следующим шагом объявляеется класс компонента библиотеки, в теле которого обязательно прописывается метод render(), который отвечает за вывод информации в DOM приложения. В конце компонента экспортируем модуль для того, чтобы он стал доступен для вызова из родительского компонента. Пример:
import React from 'react';
import './index.css';
class Head extends React.Component{
  render(){
}
}
export default Head;
Поток данных в React приложениях является однонаправленным. Это значит, для передачи данных между компонентами, необходимо всегда возвращаться к главному – <App />. Так как приложение одностраничное, все компоненты и модули приложения должны быть импортированы в index.js.

Для решения данной задачи создан компонент <EntranceLoginModal />, который содержит в себе модальное окно и следит за состоянием авторизации пользователя. Триггером выступает кнопка «Войти» для неавторизованных пользователей. В противном случае, триггером становится кнопка «Личный кабинет». Компонент включает в себя четыре режима отображения:
1. Компонент не вызван. Пользователь не авторизован. Модальное окно закрыто. Кнопка «Войти» не активна.
2. Компонент вызван. Пользователь не авторизован. Отображена форма для входа.
3. Компонент вызван. Пользователь не авторизован. Отображена форма для регистрации.
4. Компонент вызван. Пользователь авторизован. Отображено меню личного кабинета.
	Нужно рассмотреть каждый из 4 сценариев. Первый – состояние, при котором компонент скрыт, так как он не вызывается. Во втором и третьем по умолчанию в атрибуте value тега <input> задается состояние. Данный тег является полем ввода логина и пароля соответственно. Для отслеживания изменений используются функции {this.handleLoginChange}и {this.handlePasswordChange}. Также, имеется функция {this.registrationEntranceChange}, которая переключает окна между первым и вторым сценарием. При нажатии на кнопку «Войти» вызывается {this.clickLogin(e);}, на кнопку «Зарегистрироваться» – {this.messageMail(e);}}. Данные функции отображены на следующем фрагменте кода: 
  handleLoginChange(e) {
      this.setState({login: e.target.value});
      this.props.updateemailreg(e.target.value);
  }
  handlePasswordChange(e) {
      this.setState({password: e.target.value});
  }
registrationEntranceChange = (e) => {
    this.setState({
      registration: !this.state.registration
  });   }
  clickLogin(e){
    this.setState({
      actionClick: 'user_login',
      isClickedLogin: true},()=>{this.componentDidMount();}
    );
  }
  messageMail(e) {
  this.setState({
    registration: false,
    messageMail: true
    });
this.props.clickRegistration(e);
  this.setState({
    actionClick: 'register_user',
    isClickedRegistration: true},()=>{this.componentDidMount();});
}
Функции, вызывающиеся при клике на кнопки «Войти» и «Зарегистрироваться», вызывают метод   componentDidMount(), который отвечает за «общение» с сервером. Пара введенных данных (логин/пароль) принимается сервером, сервер отправляет запрос к базам данных. В случае, если пара идентична записям в БД, авторизация считается пройденной. В противном случае, выдается ошибка «Неправильный логин и/или пароль». Для проверки авторизации пользователя необходимо прибегнуть к данной технологии AJAX-запросов. В случае, если введенные данные, а именно логин и пароль, совпадают, генерируется ключ сессии на стороне сервера и записывает его в Cookies. В противном случае, состояние ключа сессии не изменяется.	
Данные пароль/логин вводятся в поля, затем, после нажатия на кнопку «Войти», формируется JSON с шифрованием, который передается серверу. Сервер посылает запрос, и, в случае совпадения данных, меняет ключ сессии на сгенерированное значение. Стоит отметить, что ключи сессии должны быть разными. Далее, срабатывает React функция, которая проверяет переменную на ключ сессии. Если он создан – состояние модального окна сменяется на true (рисунок 3.6), иначе – выводится дополнительный компонент, сообщающий об ошибке авторизации (рисунок 3.7). За формирование JSON отвечает метод fetch(), которому передаются состояния. Данный метод возвращает ключ сессии и информацию о статусе ответа от сервера. Код метода:
    fetch(this.props.api,{
         method: 'POST',
         headers: {'Content-Type':'application/json'},
         body: JSON.stringify({
           "action":this.state.actionClick,
           "login":this.state.login,
           "password":this.state.password})      })
        .then(res => res.json())
        .then(
          (result) => {
            this.setState({
              isLoaded: true,
              items: result,
              sesskey: result.sesskey,            
     });
 
Четвертый сценарий доступен только при успешной авторизации. Он отображает меню «Личного кабинета», который включает в себя следующие пункты:
●	Мои заказы. При клике на данный пункт меню запускается компонент <MyOrders />, который, в свою очередь, вызывает метод componentDidMount(). Происходит запрос на сервер с "action": 'get_zakazes' и рендеринг списка заказов.
 
●	Личные данные. Данный пункт меню вызывает окно «Личные данные» (компонент <PersonalData />). При этом происходит запрос на сервер "action": 'get_user_data' и вывод информации о пользователе: почта, логин, имя, фамилия, список компаний, список автомобилей.
 
●	Изменить пароль. Происходит запрос на изменение пароля "action": 'change_password'. Если пароль изменен успешно выводится галочка, иначе – выдается уведомление об ошибке. Внешний вид данного окна представлен на рисунке 3.10.
 
●	Выйти. Функция logaut() завершает текущий сеанс пользователя и удаляет ключ сессии. Компонент <EntranceLoginModal /> переходит в режим отображения 2.



Реализация системы поиска осуществляется в компоненте <Search />.  Он запускается сразу при инициализации web-приложения. Триггером запуска функции поиска является кнопка «Найти». По умолчанию в атрибут тега <input> value задано состояние value={this.props.searchRequest}. Состояние инициализировано через параметр props для передачи в функцию главного компонента <App />. Функция, отвечающая за изменение значения строки в поиске {this.props.handleSearchChange}.
Данная задача также предусматривает «общение» с сервером через AJAX. Пользователь вписывает интересующий его запрос в строку поиска и нажимает кнопку «Найти». Вызывается функция brandListShow() и метод componentDidMount(). Код данных функций:
handleSearchChange = (searchValue) => {
 this.setState({searchRequest: searchValue.target.value});}
brandListShow = (e) => {
  if (typeof(this.state.selectedCity) === 'undefined') {
    this.setState({
      cityAnswerModal: !this.state.cityAnswerModal   
 })  }   else {
  this.setState({
      actionClick: 'get_brands',
      actionState: this.state.searchRequest }, () =>{this.componentDidMount(e);}  )}}    
Введенные данные принимаются сервером, сервер отправляет запрос к базам данных. Далее, пользователю предлагается уточнить артикул позиции (для определения аналогов продукции и точных совпадений):
 
После выбора пользователем уточнения поиска снова происходит запрос на сервер, который выводит все позиции поиска. За это отвечает функция createTable(), запускающаяся в методе render() нового компонента <DataArray  />. Далее, воспользовавшись технологиями React, происходит разделение поисковых позиций на три категории: лучшая цена, товар в наличии, аналоги. Для определения лучшей цены в основу берется сортировка и сравнение с выбранным (эталонным) значением артикула с состояниями detail_id и brand_id. Во вторую группу товар попадает, если имеется в наличии и также совпадает по id. В последнюю – все оставшиеся позиции поиска. Все результаты поиска по умолчанию сортируются от малого к большому функциями sortByPrice() – сортировка по цене, sortByDeliveryTime() – сортировка по срокам поставки и sortByPresence – сортировка по количеству.
 
Код метода render() позиций поиска и пример функции сортировки:
createTable = (array, len, i) => {
if(this.state.createTableStop[i] === false){
  var j = 0;
  var min = len;
  var odin;
if(typeof(this.state.arrayDataCatalog) !=='undefined' && this.state.arrayDataCatalog !== 0) {
      else if (this.state.showOffers[i] === true) {
        if (n !== odin){
          return (<tr id="firstRows" key={n}><th>&#9632;</th><th >{obj.brand} {obj.article} {obj.name}</th><th title="Срок поставки">{this.state.inStockNames[i][n]}</th><th title="Количество"> {this.state.inDeliveryNames[i][n]}</th><th title="Цена">{obj.sale_price} <span >Р</span> </th>{(this.state.buttonsArrows[i][n] === false)?(<th> <button  onClick={(e)=>{this.sort1ClickBasket(obj, i, n);}}>  {(this.props.sort1Load === false)?(<img src="https://sort1.ru/wp-content/uploads/2020/02/4183831-1.gif" alt="VIN" width="23%"/>):('В корзину')}</button></th>):(<th> <button>&#10003;</button></th>)}
          </tr>);
          }
sortByPrice = (arr1, arr2, click) => {
  if (parseInt(arr1.sale_price, 10) > parseInt(arr2.sale_price, 10)) return click;
  else return !click;
}
Далее, используя функции filterBrand(array) и otherFilters (arr, n, func) реализована фильтрация по следующим параметрам:
1. производитель;
2. цена;
3. срок поставки;
4. количество.
Для этого было необходимо выбрать уникальные значения для каждого из критериев из имеющихся по данному запросу. Для строковых значений все было переведено в заглавные либо строчные буквы, во избежание дублирующихся позиций, отличающихся только регистром. Справа от параметров фильтрации располагается кнопка «Очистить все фильтры», представленная в виде воронки. Внешний вид фильтров c с примером:
 

Модальное окно реализовано в компоненте <BasketModal />. Компонент включает в себя два основных режима отображения:
1. Корзина пуста. 
2. В корзине имеются товары.
В первом случае, при клике на триггер в виде значка корзины, нужно открыть пустую корзину с кнопкой «Начать покупки».
Для реализации второго режима отображения необходимо описать логику работы корзины:
1. Рядом с каждой поисковой позиции необходимо реализовать кнопку «В корзину» в компоненте <DataArray />.
2. При нажатии на данную кнопку добавлять +1 к значению кнопки корзины, расположенной в верхней части сайта. Через компонент <BasketModal />, используя callback, изменить значение в <App /> и передать через свойства props в <Header />, отвечающий за данный блок:   
<Header clickBasketButtonNull={this.clickBasketButtonNull}  clickBasketButton={this.clickBasketButton} />.
3. В самой корзине реализовать возможность удаления позиции и редактирования ее количества (функция countPlus(count, e, znak, obj)). В зависимости от параметра znak, происходит увеличение или уменьшение количества позиции).
4. Учесть, что пользователь не может положить в корзину большее количество, чем имеется (функция countSet()).
5. Добавить кнопку очистить корзину this.props.basketDelete().
6. Запоминать количество позиций в корзине в случае выхода клиента из личного кабинета (AJAX-запрос).
 
Код функций отображения позиций в корзине:
createTable = (e) => {
    let table = []
      table=this.state.arrayBasketNew.map((obj,e)=> {
        return (
          <div key={obj.name}>
        {(this.state.count === true)?(this.countSet(obj.count, e)):(null)}
        <h2 key={obj.name}>{obj.brand} {obj.article} {obj.name}</h2>
        <div className='priceCount' id="priceDetail"><p><b>{Math.floor(obj.price * this.state.counter[e] * 10) / 10}&nbsp;<span className="rub">Р</span></b></p></div>
        <div className='priceCount' id='null'><p></p></div>
        <div className='priceCount' id='countBasket' onClick={()=>{this.countPlus(this.state.counter[e], e, -1, obj.max_count);}}><p><b>-</b></p></div>
        <div className='priceCount' id='countBasket' id='more10'> <p> {this.state.counter[e]}</p></div>
        <div className='priceCount' id='countBasket' onClick={()=>{this.countPlus(this.state.counter[e], e, 1, obj.max_count);}}><p><b>+</b></p></div>
        <div className='priceCount' id="null" id='x' onClick={()=>{this.countDelete(e);}}><p>&#10006;</p></div></div>)
      });
    return table;   }

Отображение списка заказов.
После реализации процесса добавления товаров в корзину необходимо разработать систему оформления заказа. Сценарий выполнения данной системы начинается с нажатия кнопки «Оформить заказ», расположенной в компоненте корзины в нижней части. 
Оформление заказа реализовано в 3 основных этапа:
1. Вывод всех позиций корзины с указанием количества и суммы. Выбор способа доставки, города. Заполнение данных. Итоговая сумма.
2. Оплата заказа. Выбор способа оплаты.
3. Уведомление о статусе заказа (принят/отказан).
Необходимо рассмотреть каждый этап по отдельности.
Первый этап начинается с кнопки оформления заказа в корзине. За осуществление запроса c параметром "action": 'save_zakaz' на сервер отвечает функция this.saveBasket(this.state.arrayBasketNew). В качестве аргумента выступает массив данных корзины. Через параметр props данный массив передается в компонент <OrderCheckOut />, который является ответственным за реализацию первого этапа. Функция createTable() отвечает за отображение позиций в методе render() (фрагмент кода 7). 
Далее, пользователю предложен выбор способа доставки: курьером или самовывозом. В первом случае, клиенту необходимо заполнить следующую форму:
●	Имя и фамилия. Тип поля тега <input> – text.
●	Электронная почта. Тип поля тега <input> – email.
●	Мобильный телефон. Тип поля тега <input> – tel.
●	Индекс. Тип поля тега <input> – number.
●	Адрес. Тип поля тега <input> – text.
●	Комментарий. Тип поля тега <input> – text.
Во втором:
●	Имя и фамилия. Тип поля тега <input> – text.
●	Электронная почта. Тип поля тега <input> – email.
●	Мобильный телефон. Тип поля тега <input> – tel.
Помимо заполнения данных полей, необходимо выбрать пункт самовывоза. Пункты, для удобства, представлены в виде выпадающего списка с использованием тегов <select> и <option>. Код вывода позиций корзины и реализации выпадающего списка с пунктами самовывоза: 
createTable = (array) => {
  let table = [];
  table = array.map((obj,e)=> {
return(<tr key={obj.name}><td>{obj.brand} {obj.article} {obj.name}</td><td>{obj.count} шт</td><td> {Math.floor(obj.price * obj.count * 10) /10} <span className="rub">Р</span></td></tr>)
  });
  return table; }
  {(this.state.selectedOption === false) ?
(<p id = "pointOf">  
<select value={this.props.addressSelect} onChange={this.handleChange} id="listOKOPF">{this.createListSklads(this.props.arraySkladDeliveries['sklads'])} </select></p>):
(<p id = "pointOf"> <select value={this.props.arrayCompany.address} onChange={this.handleChange} id="listOKOPF">  {this.createListAddresess(this.props.arrayCompany['delivery_addresses'])} </select></p>)}
        {this.showDelivery()}
	Также, на данном этапе предоставлена возможность изменения выбранного города. При клике на кнопку «Выбор города» открывается компонент <CityHeader />, представляющий собой модальное окно. Помимо города, необходимо выбрать филиал.
  

Переход на следующую стадию оформления заказа невозможен без согласия на обработку персональных данных. Итоговый внешний вид компонента <OrderCheckOut />.
 
Рисунок 3.16. Первый этап оформления заказа.
После завершения работы компонента <OrderCheckOut /> вызывается компонент <PayReceipt />, главная задача которого – уточнить детали заказа, в том числе способа оплаты. В качестве аргументов ему передается массив данных корзины и выбранные на предыдущем этапе опции по доставке. Компонент, используя метод render(), возвращает позиции корзины, способы доставки и предлагает выбрать способ оплаты. Возможны два варианта:
●	На сайте банковскими картами.
●	При получении заказа (картой или наличными).
При выборе первого пункта, пользователю предлагается ввести платежные данные:
●	Номер карты. Тип поля тега <input> – number.
●	Срок действия. Тип поля тега <input> – date.
●	CVC/CVV. Тип поля тега <input> – password (для того, чтобы скрыть введенные данные в целях информационной безопасности).
Если выбран пункт «при получении заказа (картой или наличными)», пользователю предлагается завершить процесс оформления заказа.
На каждом этапе заказа есть возможность вернуться на предыдущий благодаря верхней панели навигации компонентов <OrderCheckOut /> и <PayReceipt />. Для отмены процедуры оформления заказа достаточно кликнуть по логотипу, который скроет данные компоненты и обнулит состояние.
 
Показателем завершения процесса оформления заказа выступает статус ответа от сервера. В случае, если статус не выдает ошибок, заказ можно считать успешно оформленным. Далее происходит переход на главную страницу web-приложения и запускается функция обнуления товаров в корзине.
В модальном окне «Мои заказы» должна отображаться вся информация о завершенных раннее/действующих заказах с выводом итоговой стоимости и информации о каждой позиции. Заказы могут иметь следующий статус.

	Во избежание долгого ожидания загрузки списка заказов клиентом, массив данных о заказах должен быть получен сразу же при авторизации пользователя. Функция showMyOrders() запускается в компоненте <App /> во время метода render(). Условием запуска функции является проверка на авторизацию пользователя, так как получить список заказов в таком случае невозможно. Код реализации функций:
    {(this.state.auth['status'] === 'ok' && (this.state.clickedMyOrders === true || this.state.updateWithMainPage === true) && this.state.basketCountShow2 === false && this.state.authNeed2 === false)?(this.showMyOrders()):(null)}
showMyOrders = (e) => {
  this.setState({
    actionClick: 'get_zakazes',
    getZakaz: true},  () =>{this.componentDidMount(e); },
  )
}
getZakazDetail = (e)=> {
  Object.values(this.state.myOrderData['zakazs']).map((obj,e)=> {
    this.setState({
      actionClick: 'get_zakaz_details',
      updateWithMainPage: false,
      getZakazDetails: true},  () =>{this.componentDidMount(e,obj); },
  )
});}
В списке заказов отображены все заказы. Если заказ не оплачен, выводится кнопка «Оплатить».

	Таким образом, в третьей главе было приведено обоснование выбора инструментария на предмет использования в разработке web-приложения для автоматизации поиска. Были рассмотрены самые популярные фреймворки, применимые в разработке одностраничных приложений и был осуществлен выбор наиболее подходящего. Также, была определена программная платформа на стороне сервера. 
Помимо вспомогательных инструментов, были подобраны основные средства разработки программного продукта: язык разметки веб-страниц HTML, каскадные таблицы стилей CSS, мультипарадигменный язык программирования JavaScript, язык разметки векторной графики SVG.
Был описан процесс проектирования пользовательского интерфейса на основе блочного представления. Дизайн приложения строился согласно концепциям UX/UX.
 	Также, было произведено пошаговое описание разработки web-приложения для автоматизации поиска с использованием компонентного подхода библиотеки React. Был рассмотрен процесс создания компонентов с минимальными требованиями с учетом однонаправленности потока данных. Описаны логика web-приложения в целом и в частности процессы авторизации и регистрации в системе, разработки личного кабинета и осуществления процесса поиска наименований коммерческой продукции. Поэтапно была разобрана система оформления заказа и вывода списка заказов.
